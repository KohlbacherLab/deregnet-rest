# coding: utf-8

"""
    DeRegNet REST API

    DeRegNet REST API   # noqa: E501

    OpenAPI spec version: 0.0.1
    Contact: deregnet@informatik.uni-tuebingen.de
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

import pprint
import re  # noqa: F401

import six


class ParameterSet(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'default_score': 'float',
        'flip_orientation': 'bool',
        'num_suboptimal': 'int',
        'max_overlap': 'float',
        'gap_cut': 'float',
        'min_size': 'int',
        'max_size': 'int',
        'abs_values': 'bool',
        'model_sense': 'str',
        'algorithm': 'str',
        'time_limit': 'int'
    }

    attribute_map = {
        'default_score': 'default_score',
        'flip_orientation': 'flip_orientation',
        'num_suboptimal': 'num_suboptimal',
        'max_overlap': 'max_overlap',
        'gap_cut': 'gap_cut',
        'min_size': 'min_size',
        'max_size': 'max_size',
        'abs_values': 'abs_values',
        'model_sense': 'model_sense',
        'algorithm': 'algorithm',
        'time_limit': 'time_limit'
    }

    def __init__(self, default_score=None, flip_orientation=None, num_suboptimal=None, max_overlap=None, gap_cut=None, min_size=None, max_size=None, abs_values=None, model_sense=None, algorithm=None, time_limit=None):  # noqa: E501
        """ParameterSet - a model defined in Swagger"""  # noqa: E501

        self._default_score = None
        self._flip_orientation = None
        self._num_suboptimal = None
        self._max_overlap = None
        self._gap_cut = None
        self._min_size = None
        self._max_size = None
        self._abs_values = None
        self._model_sense = None
        self._algorithm = None
        self._time_limit = None
        self.discriminator = None

        if default_score is not None:
            self.default_score = default_score
        if flip_orientation is not None:
            self.flip_orientation = flip_orientation
        if num_suboptimal is not None:
            self.num_suboptimal = num_suboptimal
        if max_overlap is not None:
            self.max_overlap = max_overlap
        if gap_cut is not None:
            self.gap_cut = gap_cut
        if min_size is not None:
            self.min_size = min_size
        if max_size is not None:
            self.max_size = max_size
        if abs_values is not None:
            self.abs_values = abs_values
        if model_sense is not None:
            self.model_sense = model_sense
        if algorithm is not None:
            self.algorithm = algorithm
        if time_limit is not None:
            self.time_limit = time_limit

    @property
    def default_score(self):
        """Gets the default_score of this ParameterSet.  # noqa: E501

        Score of graph node when not defined in node score  # noqa: E501

        :return: The default_score of this ParameterSet.  # noqa: E501
        :rtype: float
        """
        return self._default_score

    @default_score.setter
    def default_score(self, default_score):
        """Sets the default_score of this ParameterSet.

        Score of graph node when not defined in node score  # noqa: E501

        :param default_score: The default_score of this ParameterSet.  # noqa: E501
        :type: float
        """

        self._default_score = default_score

    @property
    def flip_orientation(self):
        """Gets the flip_orientation of this ParameterSet.  # noqa: E501

        Find a deregulated subgraph upstream of a terminal (root)  # noqa: E501

        :return: The flip_orientation of this ParameterSet.  # noqa: E501
        :rtype: bool
        """
        return self._flip_orientation

    @flip_orientation.setter
    def flip_orientation(self, flip_orientation):
        """Sets the flip_orientation of this ParameterSet.

        Find a deregulated subgraph upstream of a terminal (root)  # noqa: E501

        :param flip_orientation: The flip_orientation of this ParameterSet.  # noqa: E501
        :type: bool
        """

        self._flip_orientation = flip_orientation

    @property
    def num_suboptimal(self):
        """Gets the num_suboptimal of this ParameterSet.  # noqa: E501

        Number of suboptimal subgraphs to find  # noqa: E501

        :return: The num_suboptimal of this ParameterSet.  # noqa: E501
        :rtype: int
        """
        return self._num_suboptimal

    @num_suboptimal.setter
    def num_suboptimal(self, num_suboptimal):
        """Sets the num_suboptimal of this ParameterSet.

        Number of suboptimal subgraphs to find  # noqa: E501

        :param num_suboptimal: The num_suboptimal of this ParameterSet.  # noqa: E501
        :type: int
        """
        if num_suboptimal is not None and num_suboptimal < 0:  # noqa: E501
            raise ValueError("Invalid value for `num_suboptimal`, must be a value greater than or equal to `0`")  # noqa: E501

        self._num_suboptimal = num_suboptimal

    @property
    def max_overlap(self):
        """Gets the max_overlap of this ParameterSet.  # noqa: E501

        Maximal overlap (node percentage) of two subgraphs  # noqa: E501

        :return: The max_overlap of this ParameterSet.  # noqa: E501
        :rtype: float
        """
        return self._max_overlap

    @max_overlap.setter
    def max_overlap(self, max_overlap):
        """Sets the max_overlap of this ParameterSet.

        Maximal overlap (node percentage) of two subgraphs  # noqa: E501

        :param max_overlap: The max_overlap of this ParameterSet.  # noqa: E501
        :type: float
        """
        if max_overlap is not None and max_overlap > 100.0:  # noqa: E501
            raise ValueError("Invalid value for `max_overlap`, must be a value less than or equal to `100.0`")  # noqa: E501
        if max_overlap is not None and max_overlap < 0:  # noqa: E501
            raise ValueError("Invalid value for `max_overlap`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_overlap = max_overlap

    @property
    def gap_cut(self):
        """Gets the gap_cut of this ParameterSet.  # noqa: E501

        Gap cut to stop optimization prematurely when the best solution found so far is within <Gap cut> * 100 percent of the best possible solution. Best found solutions are accessible as subgraphs.   # noqa: E501

        :return: The gap_cut of this ParameterSet.  # noqa: E501
        :rtype: float
        """
        return self._gap_cut

    @gap_cut.setter
    def gap_cut(self, gap_cut):
        """Sets the gap_cut of this ParameterSet.

        Gap cut to stop optimization prematurely when the best solution found so far is within <Gap cut> * 100 percent of the best possible solution. Best found solutions are accessible as subgraphs.   # noqa: E501

        :param gap_cut: The gap_cut of this ParameterSet.  # noqa: E501
        :type: float
        """
        if gap_cut is not None and gap_cut > 1:  # noqa: E501
            raise ValueError("Invalid value for `gap_cut`, must be a value less than or equal to `1`")  # noqa: E501
        if gap_cut is not None and gap_cut < 0:  # noqa: E501
            raise ValueError("Invalid value for `gap_cut`, must be a value greater than or equal to `0`")  # noqa: E501

        self._gap_cut = gap_cut

    @property
    def min_size(self):
        """Gets the min_size of this ParameterSet.  # noqa: E501

        Minimal size of a subgraph (number of nodes)  # noqa: E501

        :return: The min_size of this ParameterSet.  # noqa: E501
        :rtype: int
        """
        return self._min_size

    @min_size.setter
    def min_size(self, min_size):
        """Sets the min_size of this ParameterSet.

        Minimal size of a subgraph (number of nodes)  # noqa: E501

        :param min_size: The min_size of this ParameterSet.  # noqa: E501
        :type: int
        """
        if min_size is not None and min_size < 0:  # noqa: E501
            raise ValueError("Invalid value for `min_size`, must be a value greater than or equal to `0`")  # noqa: E501

        self._min_size = min_size

    @property
    def max_size(self):
        """Gets the max_size of this ParameterSet.  # noqa: E501

        Maximal size of a subgraph (number of nodes)  # noqa: E501

        :return: The max_size of this ParameterSet.  # noqa: E501
        :rtype: int
        """
        return self._max_size

    @max_size.setter
    def max_size(self, max_size):
        """Sets the max_size of this ParameterSet.

        Maximal size of a subgraph (number of nodes)  # noqa: E501

        :param max_size: The max_size of this ParameterSet.  # noqa: E501
        :type: int
        """
        if max_size is not None and max_size < 0:  # noqa: E501
            raise ValueError("Invalid value for `max_size`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_size = max_size

    @property
    def abs_values(self):
        """Gets the abs_values of this ParameterSet.  # noqa: E501

        Whether to take the absolute values of the provided scores as actual scores in the computation   # noqa: E501

        :return: The abs_values of this ParameterSet.  # noqa: E501
        :rtype: bool
        """
        return self._abs_values

    @abs_values.setter
    def abs_values(self, abs_values):
        """Sets the abs_values of this ParameterSet.

        Whether to take the absolute values of the provided scores as actual scores in the computation   # noqa: E501

        :param abs_values: The abs_values of this ParameterSet.  # noqa: E501
        :type: bool
        """

        self._abs_values = abs_values

    @property
    def model_sense(self):
        """Gets the model_sense of this ParameterSet.  # noqa: E501

        'max' means maximization, 'min' means minimization.  Suitability depends on the semantics of the node scores   # noqa: E501

        :return: The model_sense of this ParameterSet.  # noqa: E501
        :rtype: str
        """
        return self._model_sense

    @model_sense.setter
    def model_sense(self, model_sense):
        """Sets the model_sense of this ParameterSet.

        'max' means maximization, 'min' means minimization.  Suitability depends on the semantics of the node scores   # noqa: E501

        :param model_sense: The model_sense of this ParameterSet.  # noqa: E501
        :type: str
        """
        allowed_values = ["max", "min"]  # noqa: E501
        if model_sense not in allowed_values:
            raise ValueError(
                "Invalid value for `model_sense` ({0}), must be one of {1}"  # noqa: E501
                .format(model_sense, allowed_values)
            )

        self._model_sense = model_sense

    @property
    def algorithm(self):
        """Gets the algorithm of this ParameterSet.  # noqa: E501

        Which algorithm to use: gcc: Generalized Charnes-Cooper transform (recommended) dta: Dinkelbach-type algorithm ovt: Objective-Variable transform   # noqa: E501

        :return: The algorithm of this ParameterSet.  # noqa: E501
        :rtype: str
        """
        return self._algorithm

    @algorithm.setter
    def algorithm(self, algorithm):
        """Sets the algorithm of this ParameterSet.

        Which algorithm to use: gcc: Generalized Charnes-Cooper transform (recommended) dta: Dinkelbach-type algorithm ovt: Objective-Variable transform   # noqa: E501

        :param algorithm: The algorithm of this ParameterSet.  # noqa: E501
        :type: str
        """
        allowed_values = ["dta", "gcc", "ovt"]  # noqa: E501
        if algorithm not in allowed_values:
            raise ValueError(
                "Invalid value for `algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(algorithm, allowed_values)
            )

        self._algorithm = algorithm

    @property
    def time_limit(self):
        """Gets the time_limit of this ParameterSet.  # noqa: E501

        Time limit in second. A run is aborted if the limit is reached, in case there were feasible solutions found you can access those as subgraphs though   # noqa: E501

        :return: The time_limit of this ParameterSet.  # noqa: E501
        :rtype: int
        """
        return self._time_limit

    @time_limit.setter
    def time_limit(self, time_limit):
        """Sets the time_limit of this ParameterSet.

        Time limit in second. A run is aborted if the limit is reached, in case there were feasible solutions found you can access those as subgraphs though   # noqa: E501

        :param time_limit: The time_limit of this ParameterSet.  # noqa: E501
        :type: int
        """
        if time_limit is not None and time_limit < 0:  # noqa: E501
            raise ValueError("Invalid value for `time_limit`, must be a value greater than or equal to `0`")  # noqa: E501

        self._time_limit = time_limit

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ParameterSet):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
